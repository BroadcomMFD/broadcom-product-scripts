/* REXX - Filter/un-Filter Element Selection Lists                              
          This Rexx allows the user to filter the current displayed list/       
          table to show or hide duplicate element names. THe previous           
          table is saved, and can be restored by entering the                   
          command again without any parameters                                  
                                                                                
   Note:  One of the limitations today is that it only knows how to             
          search element names in the QuickEdit and LongName selection   not    
          later it could be expanded to support other columns and other ields   
          displays.                                                     his     
          e.g. EDUPS ele sys - to find duplicate elements withing a sys er      
          or   EDUPS -pro to show all unique processor groups                   
          */                                                                    
   TRACE o                                                                      
start = Time('E') /* start the clock */                                         
/*ADDRESS ISPEXEC "CONTROL ERRORS RETURN"*/                                     
  ADDRESS ISPEXEC "VGET (ZSCREEN ZPANELID ZUSER ZPREFIX ZSYSID)"                
  MaxRc = 0              /* default return code */                              
  ZERRALRM = NO          /* default MSg Alarm Yes|No */                         
  ZERRTP   = NOTIFY      /*             Type Notify|Warning|Action|Critical */  
  ZERRWN   = LNORESP     /*             Window RESP|NORESP|LRESP|LNORESP */     
  ZERRHM   = EDUPST      /*    "     "  EDups Tutorial panel */                 
  ADDRESS ISPEXEC "VPUT (ZERRALRM ZERRTP ZERRWN ZERRHM) shared"                 
/*                                                                              
   First thing to do is make sure we're on a valid panel and that               
   the variables we need are available...                                       
   We do this using the panel loop-up function ESORTLKP() which can             
   be modified to support additional panels as needed.                          
*/                                                                              
                                                                                
SUPPTABS = 'ENZIE250 LNZIE250'                                                  
do I = 1 to words(SuppTabs)   /* If Tables have Zs replace with scr# */         
   j = pos('Z',SuppTabs)                                                        
   if J = 0 then leave                                                          
   SUPPTABS = overlay(ZSCREEN,SuppTabs,j)                                       
END                                                                             
ELSELTBN = esortlkp(ZPANELID) /* lookup the current panel's table name */       
if wordpos(ELSELTBN,SuppTabs) = 0,                                              
 | ELSELTBN == 'INVALID' then /* Check for not supported panel         */       
  Signal BadPanel                                                               
ELSELTMP = 'EN' || ZSCREEN || 'EDUPS'                                           
                                                                                
/*                                                                              
   Mainline logic starts here                                                   
*/                                                                              
MainLine:                                                                       
                                                                                
if ARG() = 0 then call Restore_request /* If no args, put table back */         
else do                                /* Other wise we need to filter */       
   ReqType = Arg(1)                    /* save Argument                */       
   if wordpos(ReqType,"= + - M") > 0 Then/* Valid Arg?                   */     
      call Filter_request              /* and do the Filter request */          
   else                                                                         
     Signal BadArgs                                                             
end                                                                             
EXIT MaxRC                                                                      
                                                                                
/* Main Subroutines */                                                          
                                                                                
Filter_request:                                                                 
                                                                                
                                                                                
  call FindTable   /* Check ISPF table is ready to use */                       
  call BackupTbl   /* Make a temp copy of the table */                          
  call MarkTable   /* Pass through table marking duplicates */                  
  /*                                                                            
     Set messages and return to Endevor                                         
                                                                                
     Summary of Counters so far...                                              
       CNTROW - Row count of elements in source table                           
       CNTFND - Whle scanning table count of dup ele names                      
       CNTDUP - count of names that are NOT unique                              
       MAXDUP - Max count of names that are not unique                          
       CNTUNQ - count elements del because they are unique                      
       CNTUPM - count elements del because they are up the map                  
  */                                                                            
  FLTTIM = trunc(Time('E'),2) /* in case we want to track performance */        
                                                                                
  if ReqType = '=' then do /* user wants Duplicates (excluding up the map)*/    
     if MAXDUP > 0 then do                                                      
        call FormatDup     /* format table for Dups */                          
        if CNTROW - CNTUNQ + CNTUPM <= 0 then do /* did we delete all? */       
           call RestoreTBL                /* put the saved table back */        
           ZERRSM = strip(left("No dups found, except up map",24),t)            
           ZERRLM = "Selection list with" CNTROW "rows was scanned and found:", 
                    CNTDUP "Elements with the same name, of which" ,            
                    CNTUPM "Elements (of the same System/SubSystem/Type)" ,     
                    "were found up the map, and" CNTUNQ "unique elements," ,    
                    "which were hidden. ",                                      
                    "The selection list has been restored."                     
           ADDRESS ISPEXEC "control nondispl" /* and force a refresh */         
           end                                                                  
        else do                       /* we have some dups to display */        
           ZERRSM = strip(left("Dups:"CNTDUP - CNTUPM ,                         
                               "In:"CNTROW "rows",24),t)                        
           ZERRLM = "Selection list with" CNTROW "rows was scanned and found:", 
                    CNTDUP "Elements with the same name, of which" ,            
                    CNTUPM "Elements (of the same System/SubSystem/Type)" ,     
                    "were found up the map, and" CNTUNQ "unique elements," ,    
                    "which were hidden.  Use EDUP again to restore.  "          
           ADDRESS ISPEXEC "control nondispl" /* and force a refresh */         
           end                                                                  
     end                                                                        
     else do                                                                    
        call RestoreTBL                   /* put the saved table back */        
        ZERRSM = strip(left("No Duplicates In:"CNTROW "rows",24),t)             
        ZERRLM = "Selection list with" CNTROW "rows was scanned and found:",    
                 "no Elements with the same name.  If you expected" ,           
                 "to see duplicates make sure Return First Found is" ,          
                 "set to 'N' or adjust your filter. " ,                         
                 "The selection list has been restored."                        
     end                                                                        
  end                                                                           
  else if ReqType = '+' then do /* user wants Duplicates including up the map */
     if MAXDUP > 0 then do                                                      
        call FormatDup     /* format table for Dups */                          
        ZERRSM = strip(left("Dups:"CNTDUP "In:"CNTROW "rows",24),t)             
        ZERRLM = "Selection list with" CNTROW "rows was scanned and found:",    
                 CNTDUP "Elements with the same name, either" ,                 
                 "in a different System/SubSystem/Type, or found" ,             
                 "up the map, with a maximum of" MAXDUP "duplicates,",          
                 "and" CNTUNQ "unique elements," ,                              
                 "(which were hidden).  Use EDUP again to restore."             
        ADDRESS ISPEXEC "control nondispl" /* and force a refresh */            
     end                                                                        
     else do                                                                    
        call RestoreTBL                   /* put the saved table back */        
        ZERRSM = strip(left("No Duplicates In:"CNTROW "rows",24),t)             
        ZERRLM = "Selection list with" CNTROW "rows was scanned and found:",    
                 "no Elements with the same name.  If you expected" ,           
                 "to see duplicates make sure Return First Found is" ,          
                 "set to 'N' or adjust your filter. " ,                         
                 "The selection list has been restored."                        
     end                                                                        
  end                                                                           
  else if ReqType = '-' then do /* user wants Unique */                         
     if MAXDUP > 0 then do                                                      
        call FormatUniq    /* format table for Dups */                          
        ZERRSM = strip(left("Uniqe:"CNTUNQ "In:"CNTROW "rows",24),t)            
        ZERRLM = "Selection list with" CNTROW "rows was scanned and found:",    
                 CNTDUP "Elements with the same name, of which" ,               
                 CNTDEL "Elements had at least one duplicate, or" ,             
                 "were found up the map, leaving" CNTUNQ "unique" ,             
                 "elements. Use EDUP again to restore.  "                       
        ADDRESS ISPEXEC "control nondispl" /* and force a refresh */            
     end                                                                        
     else do                                                                    
        call RestoreTBL                   /* put the saved table back */        
        ZERRSM = strip(left("All Elements are unique",24),t)                    
        ZERRLM = "Table scanned" CNTROW "rows in" trunc(Time('E'),2),           
                  "seconds but did not find any non-unique elements," ,         
                  "make sure 'Return First Found' is not set to Yes"            
     end                                                                        
  end                                                                           
  else if ReqType = 'M' then do /* user wants Marked */                         
     if MAXDUP > 0 then do                                                      
        ZERRSM = strip(left("Count marked In:"CNTROW "rows",24),t)              
        ZERRLM = "Table Marked in" trunc(Time('E'),2),                          
                  "seconds and found" CNTROW-CNTDUP "unique Elements, in" ,     
                   CNTROW "rows, with a maximum of" MAXDUP "duplicates."        
        ADDRESS ISPEXEC "control nondispl" /* and force a refresh */            
     end                                                                        
  end                                                                           
  else Signal BadArgs                                                           
  /* Reposition table and return to user */                                     
  ADDRESS ISPEXEC "TBTOP" ELSELTBN                                              
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM) SHARED"                                 
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
                                                                                
  return           /* return results to user */                                 
                                                                                
Restore_Request:                                                                
                                                                                
  call FindTable   /* Check ISPF table is ready to use */                       
  ADDRESS ISPEXEC "TBSTATS" ELSELTMP "STATUS2(ELSELTM2)"                        
  if ELSELTM2 = 4 then            /* Also save the Share mode of the table    */
     TABOPT = 'SHARE'                                                           
  ELSE                                                                          
     TABOPT = ''                                                                
  if ELSELTM2 = 2 ,               /* if table is open/available */              
   | ELSELTM2 = 4 then do         /* (open in shared mode) */                   
     /* check it matches the "shape" of the current table */                    
     ADDRESS ISPEXEC "TBQUERY" ELSELTMP "KEYS(TMPKEYS) NAMES(TMPVARS)"          
     if TABKEYS = TMPKEYS,                                                      
      & TABVARS = TMPVARS then do /* good match? */                             
        call RestoreTbl           /* restore it  */                             
        ADDRESS ISPEXEC "control nondispl"  /* force a refresh */               
        ZERRSM = "Table Restored"                                               
        ZERRLM = "Previously backed up table("ELSELTMP"), containing" ,         
                  CNTROW "rows, restored."                                      
     end                                                                        
     else do                                                                    
        MaxRc   = max(MaxRc,8)                                                  
        ZERRALRM = YES         /* ring the bell */                              
        ZERRSM = "Unable to Restore"                                            
        ZERRLM = "The table" ELSELTMP "does not have the same  keys("TMPKEYS")",
               "or vars ("TMPVARS") as the source table" ELSELTMP " which has", 
               "keys("TABKEYS") and vars("TABVARS"). "                          
     end                                                                        
  end                                                                           
  else do /* currently we have no backup table, warn user and exit */           
     MaxRc   = max(MaxRc,4)                                                     
     ZERRSM = "Nothing to Restore"                                              
     ZERRLM = "Enter EDUPS with an argument '=' or '-' for Duplicates, or" ,    
              "Unique elements, or blank to restore the table. ",               
              "Use '+' to show duplicates INCLUDING up the map. ",              
              "In this case, no argument was provided, but we don't",           
              "have anything to restore yet either."                            
  end                                                                           
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM) SHARED"                        
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
                                                                                
  return           /* return results to user */                                 
                                                                                
FindTable:                                                                      
/*                                                                              
   This routine will open/check the current and backup table                    
   if the temp table is not open yet, it will create and open it                
*/                                                                              
/*                                                                              
   Table should already be open, just go check it's stats...                    
*/                                                                              
  ADDRESS ISPEXEC "TBSTATS" ELSELTBN "STATUS2(ELSELTB2)"                        
  if ELSELTB2 = 1 ,               /* if table not open in this logical screen */
   | ELSELTB2 = 3 ,               /* or table is open in WRITE mode...        */
   | ELSELTB2 = 5 then            /* or SHARED WRITE mode (not supported)     */
     signal NotOpen               /* something bad has happened - get out     */
/*                                                                              
   otherwise... Save the table keys and varnames                                
*/                                                                              
  ADDRESS ISPEXEC "TBQUERY" ELSELTBN "KEYS(TABKEYS) NAMES(TABVARS)"             
  if ELSELTB2 = 4 then            /* Also save the Share mode of the table    */
     TABOPT = 'SHARE'                                                           
  ELSE                                                                          
     TABOPT = ''                                                                
                                                                                
return                                                                          
                                                                                
MarkTable:                                                                      
/*                                                                              
   This Subroutine is used to filter the current table to find if               
   thre are any matches on the required string                                  
*/                                                                              
/* First sort the table sensibly: Element, StgSeq, System, SubSys, Type */      
      ADDRESS ISPEXEC "TBSORT "ELSELTBN,                                        
      "FIELDS(EEVETKEL,C,A" ,                                                   
             "EEVETDSL,C,A" ,                                                   
             "EEVETKSY,C,A" ,                                                   
             "EEVETKSB,C,A" ,                                                   
             "EEVETKTY,C,A)"                                                    
      SA= 'COMPLETED TBSORT  RC:'rc  ;                                          
CNTROW = 0   /* Row count of elements in source table             */            
CNTFND = 0   /* Whle scanning table count of dup ele names        */            
CNTDUP = 0   /* count of names that are NOT unique                */            
MAXDUP = 0   /* Max count of names that are not unique            */            
             /* Note for these last two values it does not take   */            
             /*      into account whether these are just the same */            
             /*      element up the map - that comes later...     */            
LSTELE = ''                               /* initialise Last Ele  */            
ADDRESS ISPEXEC "TBBOTTOM" ELSELTBN       /* Go to the Bottom     */            
   ADDRESS ISPEXEC "TBGET" ELSELTBN "SAVENAME(SAVEVARS)"                        
DO FOREVER                                                                      
   if rc <> 0 THEN LEAVE                                                        
   CNTROW = CNTROW + 1                                                          
   If LSTELE == EEVETKEL then do          /* same as last one?    */            
      CNTFND = CNTFND + 1                                                       
      if CNTFND = 1 then                  /* First Duplicate      */            
         CNTDUP = CNTDUP + 1                                                    
      if CNTFND+1 > MAXDUP then           /* check for max        */            
         MAXDUP = CNTFND+1  /* remember Cnt is based from zero!   */            
   end                                                                          
   ELSE do                                /* New Element name?    */            
      CNTFND = 0                                                                
      LSTELE = EEVETKEL                   /* save new Ele name    */            
   end                                                                          
   EEVETDMS = "Cnt:" CNTFND                                                     
   ADDRESS ISPEXEC "TBPUT"  ELSELTBN "SAVE(SAVEVARS)" /* updt ROW */            
   PUTRC = RC                                                                   
   ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(-1) SAVENAME(SAVEVARS)"            
END                                                                             
                                                                                
Return                                                                          
                                                                                
FormatDup:                                                                      
/*                                                                              
   This Subroutine is used to Format the Marked table to show the               
   duplicate entries...                                                         
   Whether we include or exclue elements up the map is determined by ReqType    
*/                                                                              
CNTUNQ = 0   /* count elements del because they are unique        */            
CNTUPM = 0   /* count elements del because they are up the map    */            
ADDRESS ISPEXEC "TBTOP"    ELSELTBN       /* Go to the top        */            
DO FOREVER                                                                      
   ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(+1) SAVENAME(SAVEVARS)"            
   if rc <> 0 THEN LEAVE                                                        
   parse value EEVETDMS with "Cnt:" DUPFND . /* get the count of dups */        
   sa= "EEVETDMS:" EEVETDMS "Cnt:" DUPFND dupFND+1                              
   if DUPFND = 0 then do                  /* Not unique?          */            
      CNTUNQ = CNTUNQ + 1                 /* Count unique ele then*/            
      ADDRESS ISPEXEC "TBDELETE" ELSELTBN /* delete it            */            
      sa= "deleting:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI     
      iterate                             /* get next record      */            
   end                                                                          
   EEVETDMS = "-+" Save_Flags()           /* Header & Save Flags  */            
   sa= "updatTop:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI        
   ADDRESS ISPEXEC "TBPUT"  ELSELTBN "SAVE(SAVEVARS)" /* updt ROW */            
   ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(+1) SAVENAME(SAVEVARS)"            
   if rc <> 0 THEN leave                                                        
   do j = DUPFND-1 to 1 by -1             /* then for each dup    */            
      sa= "j" j "get rc" rc EEVETKEL EEVETDMS                                   
      EEVETDMS = " |" Comp_Flags()        /* detail               */            
      sa= "updatMid:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI     
      ADDRESS ISPEXEC "TBPUT" ELSELTBN "SAVE(SAVEVARS)" /* updt*/               
      ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(+1) SAVENAME(SAVEVARS)"         
      if rc <> 0 THEN leave                                                     
   end                                                                          
   EEVETDMS = " +" Comp_Flags()           /* detail               */            
   sa= "updating:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI        
   ADDRESS ISPEXEC "TBPUT"  ELSELTBN "SAVE(SAVEVARS)" /* updt  */               
   if ReqType = '=' then do               /* Are we ignoring upMap*/            
      do j = 0 to dupfnd                     /* loop back deleting up map */    
         if j = DupFnd then                     /* back at the header so*/      
            CNTUPM = CNTUPM + 1                 /* del all, so count it */      
         if j = DupFnd ,                        /* back at the header   */      
          | substr(EEVETDMS,4,3) == '===',      /* same inv location    */      
          & right(EEVETDMS,1) \== '=' then do   /* but stage changed?   */      
            sa= "deleBack:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB,                
                                              EEVETKEN EEVETKSI                 
            ADDRESS ISPEXEC "TBDELETE" ELSELTBN /* delete UP the Map Ent*/      
            ADDRESS ISPEXEC "TBQUERY"  ELSELTBN "POSITION(CRPTBN)"              
            ADDRESS ISPEXEC "TBTOP"    ELSELTBN                                 
            IF CRPTBN = 0 then leave            /* we're back at the top*/      
            ADDRESS ISPEXEC "TBSKIP"   ELSELTBN,                                
                            "NUMBER("CRPTBN") SAVENAME(SAVEVARS)"               
            sa= "Re-posit:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB,                
                       EEVETKEN EEVETKSI "RC:" rc "CRP:" CRPTBN                 
         end                                                                    
         else do                                /* We found a real Dup! */      
            EEVETDMS = overlay(' +',EEVETDMS,1) /* mark this as the btm */      
            sa= "updatEnd:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB,                
                                              EEVETKEN EEVETKS                  
            ADDRESS ISPEXEC "TBPUT"  ELSELTBN "SAVE(SAVEVARS)" /* updt  */      
            leave                               /* and get out          */      
      end                                                                       
      sa= "EndClean:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI     
      END                                                                       
   END                                                                          
END                                                                             
Return                                                                          
                                                                                
FormatUniq:                                                                     
/*                                                                              
   This Subroutine is used to Format the Marked table to show the               
   unique entries only.                                                         
*/                                                                              
CNTUNQ = 0   /* count elements kept because they are unique       */            
CNTDEL = 0   /* count elements deleted because they are not-unique*/            
ADDRESS ISPEXEC "TBTOP"    ELSELTBN       /* Go to the top        */            
ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(+1) SAVENAME(SAVEVARS)" ,             
                                  "POSITION(CRPTBN)"                            
DO FOREVER                                                                      
   Sa= "Row:" CRPTBN EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKS       
   if rc <> 0 THEN LEAVE                                                        
   parse value EEVETDMS with "Cnt:" DUPFND . /* get the count of dups */        
   sa= "EEVETDMS:" EEVETDMS "Cnt:" DUPFND dupFND+1                              
   if DUPFND = 0 then do                  /* Not unique?          */            
      CNTUNQ = CNTUNQ + 1                 /* Count unique ele then*/            
      EEVETDMS = ''                       /* reset message        */            
      sa= "updatUnq:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB,                      
                                        EEVETKEN EEVETKS                        
      ADDRESS ISPEXEC "TBPUT"  ELSELTBN "SAVE(SAVEVARS)" /* updt  */            
      ADDRESS ISPEXEC "TBSKIP" ELSELTBN "NUMBER(+1)" ,                          
                      "SAVENAME(SAVEVARS) POSITION(CRPTBN)"                     
      iterate                             /* get next record      */            
   end                                                                          
   sa= "Del-Dups:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI        
   if rc <> 0 THEN leave                                                        
   do j = 0 to DUPFND                     /* for Each Dup         */            
      CNTDEL = CNTDEL + 1                 /* Count deleted rows   */            
      sa= "Deleting:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB EEVETKEN EEVETKSI     
      ADDRESS ISPEXEC "TBDELETE" ELSELTBN /* delete this dup      */            
      ADDRESS ISPEXEC "TBSKIP"   ELSELTBN,                                      
                      "SAVENAME(SAVEVARS) POSITION(CRPTBN)"                     
      sa= "Re-posit:" EEVETKEL EEVETDMS EEVETKSY EEVETKSB,                      
                 EEVETKEN EEVETKSI "RC:" rc "CRP:" CRPTBN                       
      if rc <> 0 THEN leave                                                     
   end                                                                          
END                                                                             
Return                                                                          
                                                                                
                                                                                
Save_Flags:      /* Save new values and return header             */            
SAVE_KSY = EEVETKSY                                                             
SAVE_KSB = EEVETKSB                                                             
SAVE_KTY = EEVETKTY                                                             
SAVE_PGR = EEVETPGR                                                             
SAVE_KEN = EEVETKEN                                                             
SAVE_KSX = EEVETDSL                                                             
NEXT_KSX = ''   /* we'll save it on the next row */                             
                                                                                
Return "SBTGE#" /* Just return Headers                            */            
                                                                                
Comp_Flags:      /* Compare Currnet and Saved values and set flags*/            
                                                                                
THIS_FLAG = '======'                /* Start by assuming all Equal*/            
                                    /* Which are Not Equal        */            
if EEVETKSY \== SAVE_KSY then THIS_FLAG = overlay('s',THIS_FLAG,1)              
if EEVETKSB \== SAVE_KSB then THIS_FLAG = overlay('b',THIS_FLAG,2)              
if EEVETKTY \== SAVE_KTY then THIS_FLAG = overlay('t',THIS_FLAG,3)              
if EEVETPGR \== SAVE_PGR then THIS_FLAG = overlay('p',THIS_FLAG,4)              
if EEVETKEN \== SAVE_KEN then THIS_FLAG = overlay('e',THIS_FLAG,5)              
if EEVETDSL \== SAVE_KSX then THIS_FLAG = overlay('#',THIS_FLAG,6)              
                                                                                
/* It's probably easier to read if only the flags are listed                    
   Greater than/less than doesn't make sense once sorted                        
                                    /* Which are greater?         */            
if EEVETKSY > SAVE_KSY then THIS_FLAG = overlay('>',THIS_FLAG,1)                
if EEVETKSB > SAVE_KSB then THIS_FLAG = overlay('>',THIS_FLAG,2)                
if EEVETKTY > SAVE_KTY then THIS_FLAG = overlay('>',THIS_FLAG,3)                
if EEVETPGR > SAVE_PGR then THIS_FLAG = overlay('>',THIS_FLAG,4)                
if EEVETKEN > SAVE_KEN then THIS_FLAG = overlay('>',THIS_FLAG,5)                
if EEVETDSL > SAVE_KSX then THIS_FLAG = overlay('>',THIS_FLAG,6)                
                                    /* ...and which are less?     */            
if EEVETKSY < SAVE_KSY then THIS_FLAG = overlay('<',THIS_FLAG,1)                
if EEVETKSB < SAVE_KSB then THIS_FLAG = overlay('<',THIS_FLAG,2)                
if EEVETKTY < SAVE_KTY then THIS_FLAG = overlay('<',THIS_FLAG,3)                
if EEVETPGR < SAVE_PGR then THIS_FLAG = overlay('<',THIS_FLAG,4)                
if EEVETKEN < SAVE_KEN then THIS_FLAG = overlay('<',THIS_FLAG,5)                
if EEVETDSL < SAVE_KSX then THIS_FLAG = overlay('<',THIS_FLAG,6)                
*/                                                                              
If j = DUPFND-1 then    /* is this the first row AFTER a new ele? */            
   NEXT_KSX = EEVETDSL  /* save this KSX in case we want to ignore up ma */     
sa= "j:" j "DUPFND-1:" DUPFND-1 "NEXT_KSX:" NEXT_KSX                            
                                                                                
Return THIS_FLAG /* Return all Flags                               */           
                                                                                
FilterTbl:                                                                      
/*                                                                              
   This Subroutine is used to filter the current table to find if               
   thre are any matches on the required string                                  
*/                                                                              
CNTROW = 0                                /* initialise Row count */            
CNTFND = 0                                /* initialise Fnd count */            
ADDRESS ISPEXEC "TBTOP" ELSELTBN                                                
/*                                                                              
  Note the next statement establishes the order in which fields will be         
  Interpreted before the search - an option might be to use the values set      
  by WideScrn to search in the order that they appear on the users screen       
  and/or to limit the search to variables that are visible (perhaps using       
  a parameter "HIDDEN" to enable searching all columns, or ECols setting a      
  'findable' attribute.  The final challange would be to work out whether       
  to use the primary or alternate model values... the big one? both? etc.       
  or get ECOLS to build a per-screen version of AllVars.                        
*/                                                                              
AllVars = strip(SubStr(TABKEYS,2),T,')') , /* concatenate keys and names */     
          strip(SubStr(TABVARS,2),T,')')                                        
sa= 'AllVars:"'AllVars'"'                                                       
                                                                                
DO FOREVER                                                                      
   ADDRESS ISPEXEC "TBSKIP" ELSELTBN                                            
   if rc <> 0 THEN LEAVE                                                        
   CNTROW = CNTROW + 1                                                          
   ADDRESS ISPEXEC "TBGET" ELSELTBN                                             
   ThisLine = ''                          /* initialise the substitute string */
   do i = 1 to words(AllVars)             /* append uppercased values */        
      ThisLine = strip(ThisLine,T) translate(value(word(AllVars,i)))            
   end                                                                          
   sa= ThisLine                                                                 
   if Pos(SrchStr,ThisLine) > 0 then      /* did we find the string? */         
      CNTFND = CNTFND + 1                                                       
   else                                                                         
      ADDRESS ISPEXEC "TBDELETE" ELSELTBN /* otherwise filter it */             
END                                                                             
                                                                                
Return                                                                          
                                                                                
BackupTbl:                                                                      
/*                                                                              
   First Check the Temp table                                                   
*/                                                                              
  THISTABL = ELSELTMP                     /* Name of Table for Msgs     */      
  ADDRESS ISPEXEC "TBSTATS" ELSELTMP "STATUS2(ELSELTM2)"                        
  if ELSELTM2 = 2 ,                       /* if table is open/available */      
   | ELSELTM2 = 4 then                    /* or open in shared mode     */      
     ADDRESS ISPEXEC "TBCLOSE" ELSELTMP   /* close and Free it          */      
/*                                                                              
  Make a copy of current table                                                  
*/                                                                              
  IF TABKEYS = ""                                                               
    THEN KEYTEXT = ""                                                           
    ELSE KEYTEXT = "KEYS" || TABKEYS                                            
  ADDRESS ISPEXEC 'TBCREATE' ELSELTMP ,          /* using the temp name */      
                  KEYTEXT ,                      /* same keys and vars  */      
                  'NAMES'TABVARS ,               /* AND options!        */      
                  'NOWRITE' TABOPT               /* to store a copy     */      
  If rc ^= 0 Then                                                               
     Signal BadTemp                              /*  get out on error   */      
                                                                                
  ADDRESS ISPEXEC "TBTOP" ELSELTBN                                              
  DO FOREVER                                                                    
     ADDRESS ISPEXEC "TBSKIP" ELSELTBN "SAVENAME(SAVEVARS)" /* Get next */      
     if rc <> 0 THEN LEAVE                       /* ...at end we're done*/      
     ADDRESS ISPEXEC "TBADD" ELSELTMP  "SAVE(SAVEVARS)" /* add it to tmp*/      
     if rc <> 0 THEN signal BadInsert            /* somethign wrong!    */      
  END                                                                           
                                                                                
Return                                                                          
                                                                                
RestoreTbl:                                                                     
/*                                                                              
  Time to put old table back                                                    
*/                                                                              
  THISTABL = ELSELTMP                     /* name of Table for Msgs     */      
  ADDRESS ISPEXEC "TBSTATS" ELSELTMP "STATUS2(ELSELTM2)"                        
  if ELSELTM2 = 2 ,                       /* if table is open/available */      
   | ELSELTM2 = 4 then NOP                /* or open in shared mode     */      
  else                                                                          
     signal BadTemp                       /* don't try to restore if bad*/      
  CNTROW = 0                                      /* reset counter      */      
  THISTABL = ELSELTBN                             /* name Table for Msgs*/      
  ADDRESS ISPEXEC 'TBCLOSE'  ELSELTBN             /* close live one     */      
  IF TABKEYS = ""                                                               
    THEN KEYTEXT = ""                                                           
    ELSE KEYTEXT = "KEYS" || TABKEYS                                            
  ADDRESS ISPEXEC 'TBCREATE' ELSELTBN ,           /* create a new temp  */      
                  KEYTEXT ,                       /* same keys          */      
                  'NAMES'TABVARS' NOWRITE' TABOPT /* & vars & Share mode*/      
  if rc ^= 0 Then                                                               
     Signal BadTemp                               /*  get out on error  */      
  ADDRESS ISPEXEC "TBTOP" ELSELTMP                                              
  DO FOREVER                                                                    
     ADDRESS ISPEXEC "TBSKIP" ELSELTMP "SAVENAME(SAVEVARS)" /* Get next */      
     if rc <> 0 THEN LEAVE                        /* .at end we're done */      
     ADDRESS ISPEXEC "TBADD" ELSELTBN  "SAVE(SAVEVARS)" /* add it bac   */      
     if rc <> 0 THEN signal BadInsert             /* somethign wrong!   */      
     CNTROW = CNTROW + 1                          /* othersise, count i */      
  END                                                                           
                                                                                
  ADDRESS ISPEXEC 'TBCLOSE'  ELSELTMP     /* done with copy, close it   */      
                                                                                
Return                                                                          
                                                                                
                                                                                
NotOpen:    /* table is not open - we can't do anything here! */                
  ZERRSM = "Table not Supported"                                                
  ZERRLM = "The table" ELSELTBN "is either NOT open in this logical screen" ,   
            "or is open in WRITE mode(unexpected) -" ,                          
            "EDUPS is not available"                                            
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = Critical    /* Notify|Warning|Action|Critical */                   
  ZERRWN   = RESP        /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 99                                                                       
                                                                                
BadTable:   /* table doesn't match or not enough rows! */                       
  ZERRSM = "Temp Table Stale"                                                   
  ZERRLM = "The table" ELSELTMP "does not have the same keys("TMPKEYS")",       
            "or vars ("TMPVARS") as the source table" ELSELTMP " which has",    
            "keys("TABKEYS") and vars("TABVARS"). " ,                           
            "Or the number of rows" TMPROWS " is not at least "TABROWS          
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = Action      /* Notify|Warning|Action|Critical */                   
  ZERRWN   = RESP        /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 98                                                                       
                                                                                
BadTemp:    /* Error creating temp table! */                                    
  ZERRSM = "Table Create Error"                                                 
  ZERRLM = "The table" THISTABL "coud not be created - return code:"rc          
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = Critical    /* Notify|Warning|Action|Critical */                   
  ZERRWN   = RESP        /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 97                                                                       
                                                                                
BadInsert:  /* Error inserting records! */                                      
  ZERRSM = "Table Insert Error"                                                 
  ZERRLM = "Could not add to the the table" THISTABL " - return code:"rc        
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = Critical    /* Notify|Warning|Action|Critical */                   
  ZERRWN   = RESP        /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 96                                                                       
                                                                                
BadPanel:   /* UnRecognized Panel - don't know what table to search */          
  ZERRSM = "Panel Not Supported"                                                
  ZERRLM = "This panel" ZPANELID "is not recognized as an Endevor",             
           "panel that supports EDUPS.  If you would like to be" ,              
           "able to perform filtering on this panel, please contact" ,          
           "your Endevor Administrator, or CA Field Services."                  
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = Critical    /* Notify|Warning|Action|Critical */                   
  ZERRWN   = RESP        /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 95                                                                       
BadArgs:    /* UnRecognized Arguments                               */          
  ZERRSM = "Arg ('+' or '-') required"                                          
  ZERRLM = "Use: EDUPs + to show all duplicate elements, or ",                  
           "EDUPs - to show all unique elements. " ,                            
           "EDUPs with no arguments to restore the previous state."             
  ZERRALRM = YES         /* Ring the bell */                                    
  ZERRTP   = WARNING     /* Notify|Warning|Action|Critical */                   
  ZERRWN   = NORESP      /* RESP|NORESP|LRESP|LNORESP */                        
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRALRM ZERRTP ZERRWN) SHARED"          
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ003)"                                         
  EXIT 94                                                                       
