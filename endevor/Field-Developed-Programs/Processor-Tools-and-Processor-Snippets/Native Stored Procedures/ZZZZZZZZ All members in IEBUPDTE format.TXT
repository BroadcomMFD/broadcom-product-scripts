./  ADD  NAME=@README
Member    Description
--------  ----------------------------------------------
ELEMENT   Native Stored Procedure (SP) sample element / type SQL
YAML      Native SP control table sample element / type YAML

MOVESQL   Move Processor (Deploy for Test) for type SQL
ESYMBOLS  ESYMBOLS- symbolics used by MOVESQL processor

YAML2REX  Rexx- main driver for building DB2 commands for the SP
DB2MASK2  Rexx- builds more of the DB2 commands for the SP
DB2SNAME  Rexx- finds the 'create procedure' line in the SP element
DB2SPCHK  Rexx- reads a SPUFI report to see if SP exists or is new

ENBPIU00  TableTool- comes with Endevor in CSIQCLS0

ZZZZZZZZ  All members in this dataset in IEBUPDTE format
./  ADD  NAME=DB2MASK2
/*  REXX  */

  TRACE  Off

/*    Performs masking on DB2 DDL statements                          */
/*    Variable names in mask may use an underscore to                 */
/*    replace values preceeded by multiple words.                     */
/*    Masking characters:                                             */
/*                                                                    */
/* ?  Copies a corresponding single character from source             */
/*    field to target field                                           */
/*                                                                    */
/* *  Copies 0 or more corresponding source characters                */
/*    to target field                                                 */
/*                                                                    */
/* -  Removes the single character                                    */
/*                                                                    */

   WhatDDName = 'DB2MASK2'
/* If DB2MASK# is allocated? If yes, then turn on Trace  */
   isItThere = ,
     BPXWDYN("INFO FI(EDCHKDD) INRTDSN(DSNVAR) INRDSNT(myDSNT)")
   If isItThere = 0 then Trace r
  MY_RC = 0

 /*  DB2 Masking routine for named output      */
 /*    and possible output appending           */
  Arg MYOUTDD

  Mask. = ''
  /* Cature Mask names ane values               */
  /* Read Endevor's Masking rules in the MASKING data  */
  "EXECIO * DISKR MASKING  (STEM mask.  FINIS "

  ListMaskWords   = ''
  Do m# = 1 to mask.0
     msk = Strip(mask.m#)
     posEqual = Pos('=',msk)
     if posEqual = 0 then iterate ;
     msk = overlay(' ',msk,posEqual)
     text = Substr(msk,1,(posEqual-1))
     if Words(text)/= 1 then iterate
     MaskWord = Word(msk,1)
     Upper MaskWord
     ListMaskWords = ListMaskWords MaskWord
     posValue = Wordindex(msk,2)
     MaskValue = Strip(Substr(msk,posValue))
     Say 'Found Mask for' MaskWord '=' MaskValue
     MaskValue = Strip(MaskValue,"B",'"')
     MaskValue = Strip(MaskValue,"B","'")
     Mask.MaskWord = MaskValue
  End ; /* Do m# = 1 to mask.0 */

  Say Copies('-',70)

  /* Apply mask values to Bind statement        */
  /* Read the DB2#STMT  */
  "EXECIO * DISKR DB2#STMT (Stem db2. Finis "
  /* Scan each line of the Bind Statement */
  Do b# = 1 to db2.0
     DB2Statement = db2.b#
     If Words(DB2Statement) = 0 then Iterate ;

     /* Scan each Word of the Bind Statement */
     Do m# = 1 to Words(ListMaskWords)
        MaskWord = Word(ListMaskWords,m#)
        SrchWord = Translate(MaskWord,' ','_') || ' '
        WhereMaskString = Pos(SrchWord,DB2Statement)
        If WhereMaskString < 1 then Iterate
        OrigMask  = Mask.MaskWord
        Mask  = OrigMask
        If Mask = ''  then iterate
        Call DoSubstitution
        Leave
     End; /* Do m# = 1 to Words(ListMaskWords) */

  End /*  Do b# = 1 to db2.0 */

  /* Write masked output to MYOUTDD       */
  /*   (Do not close output to allow appending of data */
  "EXECIO * DISKW" MYOUTDD "(Stem db2. "

  EXIT (MY_RC) ;

DoSubstitution :

  Say 'Before:' DB2Statement
  Sa= DB2Statement
  Sa= WhereMaskString
  Sa= MaskWord

  /* Find Starting and Ending positions of the clause */
  /* to be masked                                     */
  maskEnd = WhereMaskString + length(MaskWord) - 1
  ValueStarts = ,
     maskEnd + WordIndex(Substr(DB2Statement, maskEnd+1),1)
  BeforeChange = Word(Substr(DB2Statement, ValueStarts),1)
  valueEnd = ValueStarts + Length(BeforeChange) - 1

  /* Apply Mask to clause within the DB2 bind  */
  /* This routine applies values in 'Mask'  */
  /* to the value in 'BeforeChange'         */
  SupportedWildCards = '?*-'
  AfterChange = BeforeChange

  If Mask = ' ' then Mask ='*' ;
  Howlong = Length(Mask) + Length(AfterChange)
  Do char# = 1 to Howlong
     Maskchar = Substr(Mask,char#,1) ;
     If maskchar = " " then Leave   ;
     If maskchar = "?" then iterate ;
     If maskchar = "*" then,
        Do
        tail = Substr(Mask,char# + 1)
        Mask  = AfterChange || tail;
        char# = Max(char#,length(AfterChange) )
        Iterate ;
        End;
     If maskchar = "-" then,
        Do
        tail = Substr(AfterChange,char# + 1)
        if char# > 1 then,
           head = Substr(AfterChange,1,char# - 1)
        else,
           head = ''
        AfterChange = head || tail;
        Iterate ;
        End;
     Maskchar    = Substr(Mask,char#,1) ;
     AfterChange = Overlay(Maskchar,AfterChange,char#)
     If char# = Length(Mask) then,
        AfterChange = Substr(AfterChange,1,char#)
  End /* Do char# = 1 to Length(Mask) */

  say 'Mask:'  OrigMask
  If ValueStarts > 1 then,
       head = Substr(DB2Statement,1,ValueStarts -1)
  Else head = ''
  DB2Statement = head || AfterChange || ,
    Strip(Substr(DB2Statement,valueEnd + 1 ));
  Say 'After: ' DB2Statement
  Say Copies('-',70)

  db2.b# = DB2Statement

  Return
./  ADD  NAME=DB2SNAME
/*    REXX                                                          */
/*    Find Native Stored Procedure qualifier & name                 */
   Arg WhatDD

   "EXECIO * DISKR" WhatDD "( Stem Table. finis"
   do # = 1 to Table.0
      A = Table.#
      B = pos('CREATE PROCEDURE ',A)
      if B > 0 then do
         C = pos('.',A)
         C = C + 1
         Value = substr(A,C,32)
         Value = 'SPName ="' || Value || '"'
         Say 'DB2SNAME:' Value
         queue Value
         exit
      end
   end
./  ADD  NAME=DB2SPCHK
/*                              REXX                                 */
/*********************************************************************/
/* THIS UTILITY READS A SUPFI BATCH REPORT TO DETERMINE IF A         */
/* STORED PROCEDURE EXISTS.                                          */
/* RC=0 MEANS THE STORED PROCEDURE IS NEW.  RC=1 MEANS IT EXISTS     */
/*********************************************************************/
  'EXECIO * DISKR FILEIN (STEM TABLE.'
   DO # = 1 TO TABLE.0
     IF POS('|              0 |',TABLE.#) > 0 THEN EXIT(0)
     IF POS('|              1 |',TABLE.#) > 0 THEN EXIT(1)
   END
   SAY 'DB2SPCHK REXX ERROR: DID NOT FIND REPORT LINE'
   EXIT(12)
./  ADD  NAME=ELEMENT
    CREATE PROCEDURE ????????.YIPPIE_KAY_YAY
      (
       OUT X CHAR(1) CCSID EBCDIC FOR SBCS DATA
      )
      VERSION V1
      LANGUAGE SQL
      DETERMINISTIC
      MODIFIES SQL DATA
      CALLED ON NULL INPUT
      DYNAMIC RESULT SETS         0
      DISABLE DEBUG MODE
      PARAMETER CCSID EBCDIC
      QUALIFIER YourQualifier
      PACKAGE OWNER YourOwner
      ASUTIME LIMIT 1000
      COMMIT ON RETURN NO
      INHERIT SPECIAL REGISTERS
      WLM ENVIRONMENT FOR DEBUG MODE YourDb2WLM
      CURRENT DATA NO
      DEGREE 1
      DYNAMICRULES RUN
      APPLICATION ENCODING SCHEME EBCDIC
      WITHOUT EXPLAIN
      WITHOUT IMMEDIATE WRITE
      WITHOUT KEEP DYNAMIC
      ISOLATION LEVEL CS
      OPTHINT ''
      RELEASE AT COMMIT
      REOPT NONE
      VALIDATE RUN
      ROUNDING DEC_ROUND_HALF_EVEN
      DATE FORMAT ISO
      DECIMAL( 15 )
      FOR UPDATE CLAUSE REQUIRED
      TIME FORMAT ISO
      BUSINESS_TIME SENSITIVE YES
      SYSTEM_TIME SENSITIVE YES
      ARCHIVE SENSITIVE YES
      APPLCOMPAT V12R1
      CONCENTRATE STATEMENTS OFF
RETURN X;

./  ADD  NAME=ENBPIU00
See your site's CSIQCLS(ENBPIU00) member for the latest TableTool

./  ADD  NAME=ESYMBOLS
ESYMBOLS TITLE 'SITE-WIDE SYMBOLICS TABLE'
***********************************************************************
*  COPYRIGHT (C) 2022 BROADCOM. ALL RIGHTS RESERVED.                  *
*  NAME:        ESYMBOLS                                              *
*  DESCRIPTION: Site-Wide Symbolics Definition Table                  *
*  FUNCTION:    Define symbolics for use in element type definitions  *
*               and processors.                                       *
***********************************************************************
* DEPLOY FOR TEST (D4T) MAPPING                                       *
***********************************************************************
* ATST (DEV)
         $ESYMBOL SYMNAME=#ATSTD4T,                                    X
               SYMDATA='Y'
         $ESYMBOL SYMNAME=#ATSTLDB,                                    X
               SYMDATA='Your.Team.DEV.ATST.LOADLIB'
         $ESYMBOL SYMNAME=#ATSTLDC,                                    X
               SYMDATA='Your.Team.DEV.ATST.CICSLOAD'
         $ESYMBOL SYMNAME=#ATSTLST,                                    X
               SYMDATA='Your.Team.DEV.ATST.LISTLIB'
         $ESYMBOL SYMNAME=#ATSTDBR,                                    X
               SYMDATA='Your.Team.DEV.ATST.DBRM'
* BTST (DEV)
         $ESYMBOL SYMNAME=#BTSTD4T,                                    X
               SYMDATA='Y'
         $ESYMBOL SYMNAME=#BTSTLDB,                                    X
               SYMDATA='Your.Team.DEV.BTST.LOADLIB'
         $ESYMBOL SYMNAME=#BTSTLDC,                                    X
               SYMDATA='Your.Team.DEV.BTST.CICSLOAD'
         $ESYMBOL SYMNAME=#BTSTLST,                                    X
               SYMDATA='Your.Team.DEV.BTST.LISTLIB'
         $ESYMBOL SYMNAME=#BTSTDBR,                                    X
               SYMDATA='Your.Team.DEV.BTST.DBRM'
* CTST (DEV)
         $ESYMBOL SYMNAME=#CTSTD4T,                                    X
               SYMDATA='Y'
         $ESYMBOL SYMNAME=#CTSTLDB,                                    X
               SYMDATA='Your.Team.DEV.CTST.LOADLIB'
         $ESYMBOL SYMNAME=#CTSTLDC,                                    X
               SYMDATA='Your.Team.DEV.CTST.CICSLOAD'
         $ESYMBOL SYMNAME=#CTSTLST,                                    X
               SYMDATA='Your.Team.DEV.CTST.LISTLIB'
         $ESYMBOL SYMNAME=#CTSTDBR,                                    X
               SYMDATA='Your.Team.DEV.CTST.DBRM'
*
*
*
*Symbol Definition Examples:                                          *
*
* Example DSN High Level Qualifier:
         $ESYMBOL SYMNAME=#HLQ,SYMDATA='Your.Application.HLQ'
*
*
***********************************************************************
* LAST INVOCATION - END THE TABLE GENERATION
*---------------------------------------------------------------------*
         $ESYMBOL CALL=END
         END
./  ADD  NAME=MOVESQL
//********************************************************************
//MOVESQL PROC AAA=,
//        CSIQCLS0='Your.Endevor.CSIQCLS0',
//        HLQ='Your.Team',
//        PFXS='&HLQ..&C1SSTAGE..&C1SSUBSYS.',
//        PFXT='&HLQ..&C1STAGE..&C1SU.',
//        REXXLIB='Your.Team.$REXX',
//        SHOWME='Y',
//        SITEDBR='&#&C1SUBSYS.DBR',   DBRM
//        SITESQL='&#&C1SUBSYS.SQL',   Deploy for Test Target Dsn
//        SITETRG='&#&C1SUBSYS.D4T',   Deploy for Test Target Y/N
//        SQL#SRC='&PFXS..SQL',        Sending SQL library
//        SQL#TRG='&PFXT..SQL',        Target  SQL library
//        TUNIT='VIO',                 UNIT FOR TEMP DSNS
//        ZZZ=
//*
//**=================================================================**
//  IF (&SITETRG = 'Y') THEN
//**********************************************************************
//*  Going to do "masking" of the SQL.
//*   Get The YAML controls for this System
//**********************************************************************
//GETYAML  EXEC PGM=CONWRITE,PARM='EXPINCL(Y)',MAXRC=0     MOVESQL
//YAMLDB2  DD DSN=&&YAMLDB2,DISP=(,PASS),
//            SPACE=(TRK,(1,5)),UNIT=SYSDA,
//            DCB=(RECFM=FB,LRECL=180,BLKSIZE=7200)
//CONWIN   DD *
WRITE ELEMENT &C1SY
   FROM ENV &C1EN SYS &C1SY SUB &C1SSUBSYS
   TYPE YAML STAGE &C1STGID
   TO   DDN YAMLDB2
   OPTION SEARCH .
/*
//**=================================================================**
//BILDMASK EXEC PGM=IRXJCL,
//         PARM='ENBPIU00 PARMLIST',MAXRC=4,COND=(4,LE)
//SYSEXEC   DD DISP=SHR,DSN=&CSIQCLS0
//          DD DISP=SHR,DSN=&REXXLIB
//SYSTSPRT  DD SYSOUT=*
//PARMLIST  DD *
  NOTHING   NOTHING  OPTIONS   0
  MASKMODL  MASKING  OPTIONS1  A
  BPIOPIN   BPIOPOUT OPTIONS1  A
  CONNECTI  CONNECTO OPTIONS1  A
  DROPIN    DROPOUT  OPTIONS1  A
  SPUFIIN   SPUFIOUT OPTIONS1  A
//TABLE     DD *
* Do
  *
//YAMLDB2   DD DSN=&&YAMLDB2,DISP=(OLD,DELETE)
//YAML2REX  DD DUMMY   <- Turn on/off Trace
//SQLSRC    DD DISP=SHR,DSN=&SQL#SRC(&C1ELEMENT)
//OPTIONS   DD *       <- Convert YAML to REXX
* Convert YAML to REXX   **
 Call YAML2REX 'YAMLDB2'
 HowManyYamls = QUEUED();
 If HowManyYamls < 1 then, +
    Do; Say 'YAML2REX: Not finding any Rexx converted from YAML'; +
    Exit(8); +
    End;
 Say 'HowManyYamls=' HowManyYamls
 Do yaml# =1 to HowManyYamls; +
    Parse pull yaml2rexx; +
    Interpret yaml2rexx ; +
 End
 Call DB2SNAME 'SQLSRC'
 Lines = QUEUED();
 Do Loop# =1 to Lines; +
    Parse pull SPName; +
    Interpret SPName ; +
 End
//OPTIONS1  DD *
*  Now build Outputs from Rexx created from YAML
 thisDB2_Subsytem_ID = Value('&C1SY..&C1SU..DB2_Subsytem_ID')
 thisSQLID     = USERID()
 thisOWNER     = Value('&C1SY..&C1SU..Bind_Owner_Target_Pattern')
 thisQUALIFIER = Value('&C1SY..&C1SU..Bind_Qualifier_Target_Pat')
 thisSchema    = Value('&C1SY..&C1SU..Schema_Target_Pattern')
 thisSPName    = Value('SPName')
 VERSION  = '&VERSION'
 NAME     = '&ELEMENT'
//****** MASKING ************************************************
//MASKMODL  DD *                                <-Build 'MASK' for DB2
  CONNECT         = '&thisDB2_Subsytem_ID'
  PACKAGE_OWNER   = '&thisOWNER'
  QUALIFIER       = '&thisQUALIFIER'
  CREATE_PROCEDURE = '&thisSchema.&thisSPName                        '
//MASKING   DD DSN=&&MASKING,DISP=(,PASS),      <-Output Mask
//     SPACE=(TRK,(1,1)),UNIT=SYSDA,
//     LRECL=080,RECFM=FB,BLKSIZE=0
//****** BPIOPT *************************************************
//BPIOPIN   DD *                                <-BPIOPT input
.CONTROL BPID(PTIDEVL.VIRTUEL.DB2-JPMCSP) +
 LOGID(&thisDB2_Subsytem_ID) UNIT(SYSDA)
.LIST SYSOUT(A)
.OPTION   ERRORS NOSQLERRORS RETRY(04) NOBINDERRORS    +
   SQLFORMAT(SQL)
.RESTART SYNC
.CONNECT &thisDB2_Subsytem_ID
//BPIOPOUT  DD DSN=&&BPIOPT,DISP=(,PASS),       <-DBTool cntlcard
//     SPACE=(TRK,(1,1)),UNIT=SYSDA,
//     LRECL=080,RECFM=FB,BLKSIZE=0
//****** CONNECT command **************************************
//CONNECTI  DD *
.CONNECT &thisDB2_Subsytem_ID
//CONNECTO  DD DSN=&&CONNECT(CONNECT),DISP=(,PASS),  <-CONNECT
//     SPACE=(TRK,(1,1,5)),UNIT=SYSDA,
//     DCB=(LRECL=080,RECFM=FB,BLKSIZE=0,DSORG=PO)
//****** DROP & COMMIT    used by existing Stored Procedures ****
//DROPIN    DD *                                <-Build DROP & COMMIT
 DROP PROCEDURE &thisSchema.&thisSPName ;
 COMMIT ;
//DROPOUT   DD DSN=&&DROP(DROP),DISP=(,PASS),   <-DROP & COMMIT
//     SPACE=(TRK,(1,1,5)),UNIT=SYSDA,
//     DCB=(LRECL=080,RECFM=FB,BLKSIZE=0,DSORG=PO)
//****** SPUFI- used to check status of a Stored Procedure ****
//SPUFIIN   DD *                                <-Build DROP & COMMIT
 SELECT COUNT(*)
 FROM SYSIBM.SYSROUTINES A
 WHERE A.SCHEMA = '&thisSchema'
 AND A.NAME = '&thisSPName'
//SPUFIOUT  DD DSN=&&SPUFI,DISP=(,PASS),        <-SPUFI check command
//     SPACE=(TRK,(1,1)),UNIT=SYSDA,
//     DCB=(LRECL=080,RECFM=FB,BLKSIZE=0)
//*-------------------------------------------------------------------*
//* SHOWME: DISPLAY the MASK values
//*-------------------------------------------------------------------*
//SHOWME   EXEC PGM=IEBGENER,COND=(4,LE)                   MOVESQL
//SYSPRINT DD DUMMY
//SYSUT1   DD *
 ************ Mask ****************
//         DD DSN=&&MASKING,DISP=(OLD,PASS)
//         DD *
 ************ BPIOPT **************
//         DD DSN=&&BPIOPT,DISP=(OLD,PASS)
//         DD *
 ************ DROP ****************
//         DD DSN=&&DROP(DROP),DISP=(OLD,PASS)
//         DD *
 ************ CONNECT *************
//         DD DSN=&&CONNECT(CONNECT),DISP=(OLD,PASS)
//         DD *
 ************ SPUFI   *************
//         DD DSN=&&SPUFI,DISP=(OLD,PASS)
//SYSUT2   DD SYSOUT=*
//SYSIN    DD DUMMY
//*-------------------------------------------------------------------*
//*  Apply DB2 Masking (if necessary)
//*-------------------------------------------------------------------*
//DB2MASK  EXEC PGM=IRXJCL,PARM='DB2MASK2 DB2#NEW',        MOVESQL
//              MAXRC=4,COND=(4,LE)
//MASKING  DD DSN=&&MASKING,DISP=(OLD,DELETE)
//SYSEXEC  DD DISP=SHR,DSN=&REXXLIB
//SYSTSPRT DD SYSOUT=*
//DB2MASK2 DD DUMMY
//SHOWME   DD SYSOUT=*
//DB2#STMT DD DISP=SHR,DSN=&SQL#SRC(&C1ELEMENT)      <-In
//DB2#NEW  DD DISP=SHR,DSN=&SQL#TRG(&C1ELEMENT),     <-Out
//            MONITOR=COMPONENTS,FOOTPRNT=CREATE
//*-------------------------------------------------------------------*
//*  SPUFI batch to check status of the Stored Procedure
//*-------------------------------------------------------------------*
//SPUFI    EXEC PGM=IKJEFT01,COND=(4,LE)
//STEPLIB  DD DISP=SHR,DSN=Your.Db2.SNSNLOAD
//SYSTSPRT DD DUMMY
//SYSPRINT DD DSN=&&SPUFIRPT,DISP=(,PASS),SPACE=(TRK,(1,1)),
//            UNIT=VIO,DCB=(RECFM=FB,LRECL=133,BLKSIZE=0)
//SYSUDUMP DD SYSOUT=*
//SYSTSIN  DD *
 DSN 'SYSTEM(YourDb2SubSys)
 RUN PROGRAM(DSNTEP2) PLAN(DSNTEP12) LIB('Your.Db2.SPUFI.RUNLIB')  +
     PARMS('/ALIGN(MID)')
 END
//SYSIN    DD DSN=&&SPUFI,DISP=(OLD,DELETE)
//*
//****************************************************************
//* THIS UTILITY READS A SUPFI BATCH REPORT TO DETERMINE IF A    *
//* STORED PROCEDURE EXISTS.                                     *
//* RC=0 MEANS THE STORED PROCEDURE IS NEW. RC=1 MEANS IT EXISTS *
//****************************************************************
//SPCHECK  EXEC PGM=IKJEFT1B,PARM='%DB2SPCHK',COND=(4,LE),MAXRC=1
//SYSEXEC  DD DISP=SHR,DSN=Your.Team.$REXX
//SYSTSPRT DD DUMMY
//SYSPRINT DD DUMMY
//SYSTSIN  DD DUMMY
//SYSIN    DD DUMMY
//FILEIN   DD DSN=&&SPUFIRPT,DISP=(OLD,DELETE)
//*
//*-------------------------------------------------------------------*
//*  Broadcom's DB Tools to refresh/create the Stored Procedure
//*-------------------------------------------------------------------*
//DBTOOLS  EXEC PGM=PTLDRIVM,PARM='EP=BPLBCTL',
//              MAXRC=4,COND=(4,LE)
//****** This is for brand new Stored Procedures
//   IF (SPCHECK.RC EQ 0) THEN
//BPIIPT   DD DSN=&&CONNECT(CONNECT),DISP=(OLD,DELETE)
//         DD DISP=SHR,DSN=&SQL#TRG(&C1ELEMENT)
//***ELSE this SP exists / active
//   ELSE
//BPIIPT   DD DSN=&&CONNECT(CONNECT),DISP=(OLD,DELETE)
//         DD DSN=&DROP(DROP),DISP=(OLD,DELETE)
//         DD DISP=SHR,DSN=&SQL#TRG(&C1ELEMENT)
//   ENDIF
//BPIOPT   DD DSN=&&BPIOPT,DISP=(OLD,DELETE)   <- DBTOOLs cntlcard
//STEPLIB  DD DISP=SHR,DSN=Your.DBTools.CDBALOAD
//         DD DISP=SHR,DSN=Your.Db2.SNSNEXIT
//         DD DISP=SHR,DSN=Your.Db2.SNSNLOAD
//PTILIB   DD DISP=SHR,DSN=Your.DBTools.CDBALOAD
//         DD DISP=SHR,DSN=Your.Db2.SNSNEXIT
//         DD DISP=SHR,DSN=Your.Db2.SNSNLOAD
//PTIPARM  DD DISP=SHR,DSN=Your.DBTools.CDBAPARM
//PTIXMSG  DD DISP=SHR,DSN=Your.DBTools.CDBAXMSG
//SYSOUT   DD SYSOUT=*
//PTIIMSG  DD SYSOUT=*
//UTPRINT  DD SYSOUT=*
//ABNLIGNR DD DUMMY                 SUPPRESS ABENDAID DUMPS
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(30,30))
//SYSREC   DD UNIT=SYSDA,SPACE=(TRK,(1,1))
//*
//*******************************************************************
//  ELSE
//*********************************************************************
//* READ SOURCE AND EXPAND INCLUDES
//*********************************************************************
//CONWRITE EXEC PGM=CONWRITE,MAXRC=0,   <- Write to D4T/stage library
// PARM='EXPINCL(Y)'
//ELMOUT   DD DSN=&SQL#TRG,                  (&C1ELEMENT)
//            MONITOR=COMPONENTS,DISP=SHR,
//            FOOTPRNT=CREATE
//SYSUT3   DD UNIT=&TUNIT,SPACE=(TRK,(1,1))
//SYSUT4   DD UNIT=&TUNIT,SPACE=(TRK,(1,1))
//SYSPRINT DD SYSOUT=*
//  ENDIF
//**=================================================================**
./  ADD  NAME=YAML
# DB2 for ACEP at various Endevor Deploy to Test locations
  FINANCE:
     ATST :
        DB2_Subsytem_ID           : 'D12A'
        Bind_Owner_Target_Pattern : '*'
        Plan_Name_Target_Pattern  : '*A'
        Bind_Qualifier_Target_Pat : '*_0A'
        Schema_Target_Pattern     : 'IBMUSER'
     BTST :
        DB2_Subsytem_ID           : 'D12A'
        Bind_Owner_Target_Pattern : 'BBADBA'
        Plan_Name_Target_Pattern  : '*B'
        Bind_Qualifier_Target_Pat : '*_0B'
        Schema_Target_Pattern     : 'IBMUSER'
     CTST :
        DB2_Subsytem_ID           : 'D12A'
        Bind_Owner_Target_Pattern : '*'
        Plan_Name_Target_Pattern  : '*C'
        Bind_Qualifier_Target_Pat : '*_0C'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL01:
        DB2_Subsytem_ID           : 'D01G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*1'
        Bind_Qualifier_Target_Pat : '*_01'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL02:
        DB2_Subsytem_ID           : 'D01G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*2'
        Bind_Qualifier_Target_Pat : '*_02'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL03:
        DB2_Subsytem_ID           : 'D03G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*5'
        Bind_Qualifier_Target_Pat : '*_05'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL06:
        DB2_Subsytem_ID           : 'D01G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*3'
        Bind_Qualifier_Target_Pat : '*_03'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL07:
        DB2_Subsytem_ID           : 'D01G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*4'
        Bind_Qualifier_Target_Pat : '*_04'
        Schema_Target_Pattern     : 'IBMUSER'
     CICSAL51:
        DB2_Subsytem_ID           : 'D03G'
        Bind_Owner_Target_Pattern : 'ACEDBA'
        Plan_Name_Target_Pattern  : '*6'
        Bind_Qualifier_Target_Pat : '*_06'
        Schema_Target_Pattern     : 'IBMUSER'
./  ADD  NAME=YAML2REX
/*    REXX  - Convert YAML to REXX.                                  */
/*     in some cases Stem arrays, to support Mainframe processing    */
   isItThere = ,
     BPXWDYN("INFO FI(YAML2REX) INRTDSN(DSNVAR) INRDSNT(myDSNT)")
   If isItThere = 0 then TraceRc = 1
   Arg  WhatDD .
   /*                                                                */
   /* Process the input YAML file identified by Whatdd.              */
   /* Queue REXX equivalent statements onto the stack                */
   /* The value of each statement is either numeric                  */
   /* or quoted with double quotes.                                  */
   /*                                                                */
   /* Caller can then safely Interpret them.                         */
   /*                                                                */

   /* Read the YAML data, stor into yaml. stem array     */
   "EXECIO * DISKR" WhatDD "( Stem yaml. finis"

   /* Set initial/default values    */
   $Numbers   = '0123456789.' ;
   Call InitializeRexxVariables ;

   /* Process each YAML record -2nd pass - create REXX     variables */
   Do y# = 1 to yaml.0
      yamlrec = yaml.y#
      /* Previous indent becomes what we just processed */
      PreviousIndent# = Word(IndentTrail,1)
      CallingFrom = 'DoLoop'
      validrec = FirstLookAtIndentation() ;
      if validrec = 0 then Iterate
      validrec = CloserLookAtYamlrecall() ;
      Call  YAMLRecordToRexx
   End /* Do y# = 1 to yaml.0  */

   /* Place Rexx statements onto the stack for caller */
   RexxCounter =  newRexx.0
   Do rx# = 1 to RexxCounter
      If TraceRc = 1 then,
         Say 'YAML2REX:' newRexx.rx#
      Queue  newRexx.rx#
   End

   If TraceRc = 1 then,
         Say 'YAML2REX: exiting '
   Exit

InitializeRexxVariables:

   /* Set initial/default values    */
   PreviousIndent# = 0;             /* Assume text starts in col 1 */
   IndentLevel_Rexxnodes.   = ''    /* node to use with REXX stmts */
   IndentLevel_UpperIndent. = 0     /* Level of upper    indentation*/
   IndentTrail = '0 '               /* Hist of indents old to new   */

   ListRexxVariables = ' '     /* Identify each unique Rexx variable */
   ListRexxVarCounts. = 0      /* Counts for    unique Rexx variable */
   Verbose = 'N'               /* Can be set/reset in yaml           */
   listing = 'na'
   newRexx.     = ''           /* Replacement REXX stmts to be here  */
   newRexx.0    = 0

   indent#     =  0
   YamlListCounter. = 0        /* 0=> not a list >0 counting listed  */
   multindent# =  0

   Return;

FirstLookAtIndentation:

   /* Bypass blank lines and comment lines */
   if Words(yamlrec) = 0 then Return 0 ; /* Blank line */
   whereComment = FindCommentPosition()
   if whereComment = 1 then Return 0 ;   /* Comment line */
   else
   if whereComment = 0 then NOP
   Else,     /* Eliminate comment portion of Yaml line */
     Do
     yamlrec = Substr(yamlrec,1,(whereComment -1))
     if Words(yamlrec) = 0 then Return 0
     End

   /* Find where no-blank text starts */
   indent# = WordIndex(yamlrec,1)
   startChar = Substr(yamlrec,indent#,1)   /*First char on YAML line */

   If CallingFrom = 'ConvertListedText' then Return 1

   /* If there is a leading '-' then in a Yaml list    */
   If startChar = '-' then,
      Do
      /* Replace the '-' with a space */
      yamlrec = Overlay(' ',yamlrec,indent#)
      indent# = WordIndex(yamlrec,1)
      End

   Return 1

FindCommentPosition:

   Start =1
   Do forever
      If Start >= length(yamlrec) then Return 0
      foundComment = Pos('#',yamlrec,Start);
      if foundComment = 0 then Return 0
      OpenSingleQt = Pos("'",yamlrec,Start);
      ClosSingleQt = Pos("'",yamlrec,OpenSingleQt+1)
      OpenDoubleQt = Pos('"',yamlrec,Start);
      ClosDoubleQt = Pos('"',yamlrec,OpenDoubleQt+1)
      If foundComment > OpenSingleQt &,
         foundComment < ClosSingleQt then,
         Start = ClosSingleQt + 1
      Else,
      If foundComment > OpenDoubleQt &,
         foundComment < ClosDoubleQt then,
         Start = ClosDoubleQt + 1
      Else Return foundComment
   End /* Do forever */

   Return foundComment

CloserLookAtYamlrecall:

   /* If there is a change in indentation, then record the change */
   PreviousIndent# = Word(IndentTrail,1)
   If indent# /=  PreviousIndent#  then, /* changed indentation */
      IndentTrail = indent# IndentTrail

   /* If there is just a Yaml listed item, return      */
   If startChar /= '-' & pos(': ',yamlrec) = 0 then Return 1 then,

   /* Parse the Yaml entry, capturing YamlObect and YamlValue   */
   Parse VAR yamlrec  YamlObject ": " YamlValue

   /* Replace spaces in YamlObect with underscore chars '_'     */
   YamlObject    = Translate(Strip(YamlObject),'_',' ')

   /* Special handling of quote characters here.....            */
   YamlValue = Strip(YamlValue)
   $firstchar = Substr(YamlValue,1,1)
   $nextQuote = 0
   If ($firstchar = "'" | $firstchar = '"') then,
      $nextQuote = Pos($firstchar,YamlValue,2)
   /* A quote character at beginning and end ?  */
   If ($nextQuote  = Length(YamlValue)) then,
      YamlValue = Strip(YamlValue,'B',$firstchar)
   Else,
      YamlValue = Translate(YamlValue,"'",'"')

   /* You can selectively turn on the trace here.......         */
   If YamlObject = 'Insert??t'   then Trace ?r

   /* Manage the tracking of Yaml indentations */
   If indent# < PreviousIndent# then, /* decreased indentation */
      Call DecreasingIndentation ;
   Else,
   If indent# > PreviousIndent# then, /* increased indentation */
      Call IncreasingIndentation
   Else,
   If indent# = PreviousIndent# then, /* matching  indentation */
      Call MatchingIndentation /* same indentation level  */

   Return 1

DecreasingIndentation:

   /*  Indentation just Increased     */

   /* Use IndentTrail to find upper indentation for this one */
   upperIndent# = GetUpperIndent#()
   /* What did we find looking upward ?*/
   IndentLevel_UpperIndent.indent# = upperIndent#
   /* Get the Rexx nodes from upward locations  */
   UpperVarb = Word(IndentLevel_Rexxnodes.upperIndent#,1)
   /* Make this YamlObject 1st in the list here  */
   If upperIndent# = 0 then,
      CurrentVarb = YamlObject
   Else,
      CurrentVarb = UpperVarb'.'YamlObject
   CurrentNodes = IndentLevel_Rexxnodes.indent#
   If WordPos(CurrentVarb,CurrentNodes) = 0 then,
      IndentLevel_Rexxnodes.indent# =,
         CurrentVarb IndentLevel_Rexxnodes.indent#
   Else,
      Do
      If startChar = '-' |,                      /* YAML starting list*/
         YamlListCounter.indent# > 0 then,
         YamlListCounter.indent# = YamlListCounter.indent# + 1 ;
      IndentLevel_Rexxnodes.indent# = CurrentVarb
      End
   /* If previousIndent was listing, it will have to start over */
   YamlListCounter.PreviousIndent# = 0
   IndentLevel_UpperIndent.PreviousIndent# = indent#

   Return

IncreasingIndentation:

   /*  Indentation just Increased     */
   upperIndent# = PreviousIndent#
   If startChar = '-' then,                   /* YAML starting list*/
      YamlListCounter.indent# = 1 ;           /* count listed items*/

   /*  Assume prev indentation is upper indentation     */
   UpperVarb = Word(IndentLevel_Rexxnodes.PreviousIndent#,1)
   /* Make this YamlObject 1st in the list here  */
   If PreviousIndent# = 0 then,
      CurrentVarb = YamlObject
   Else,
      CurrentVarb = UpperVarb'.'YamlObject
   If PreviousIndent# = 0 then,
      IndentLevel_Rexxnodes.indent# =  YamlObject
   Else,
      IndentLevel_Rexxnodes.indent# =,
         CurrentVarb IndentLevel_Rexxnodes.indent#
   /* At this level, capture reference to upper level  */
   IndentLevel_UpperIndent.indent# = PreviousIndent#

   Return

MatchingIndentation:

   /*  Indentation remainded the same */

   upperIndent# = IndentLevel_UpperIndent.indent#
   /* Get the Rexx nodes from upward locations  */
   UpperVarb = Word(IndentLevel_Rexxnodes.upperIndent#,1)
   /* Make this YamlObject 1st in the list here  */
   If upperIndent# = 0 then,
      CurrentVarb = YamlObject
   Else,
      CurrentVarb = UpperVarb'.'YamlObject
   CurrentNodes = IndentLevel_Rexxnodes.indent#
   /* If the variable a repeating variable at this level? */
   If WordPos(CurrentVarb,CurrentNodes) = 0 then, /* no  */
      IndentLevel_Rexxnodes.indent# =,
         CurrentVarb CurrentNodes                 /* yes*/
   Else,
      Do /* Repeating a YamlObject name, increment */
      IndentLevel_Rexxnodes.indent# = CurrentVarb
      If YamlListCounter.indent# > 0 then,
         YamlListCounter.indent# = YamlListCounter.indent# + 1 ;
      End /* If YamlListCounter.indent# > 0 */

   Return

GetupperIndent#:

   /* Use IndentTrail to find upper indent value for just found */
   /*     Yaml line with changed indentation.                   */
   Do trl# =  1 to Words(IndentTrail)  /* find its outer indent*/
      happyTrails = Word(IndentTrail,trl#)
      If happyTrails < indent# then Return happyTrails
   End /* Do Forever.... search for next upper indentation */

   Return 0


ConvertListedText:

   /* Finding text listed in Yaml. Use Rexx YamlListCounter in output */
   RexxCounter =  newRexx.0 + 1
   peek_y# = next_y# + 1
   /* Multi-lines ? if value is |  or   >       */
   multindent# = WordIndex(yaml.peek_y#,1)
   IndentLevel_UpperIndent.multindent# = indent#
   upperIndent# = indent#
   endLinechar = '15'x  /* Ebcdic end-of-line char */
   TextCounter =  1
   CallingFrom = 'ConvertListedText'
   Do Forever
      next_y# = next_y# + 1
      if next_y# > yaml.0 then Leave
      yamlrec     = Strip( yaml.next_y#,'T')
      validrec = FirstLookAtIndentation() ;
      if indent# < multindent# then leave;
      if validrec = 0 then Iterate
      yamlrec     = Substr(yamlrec,multindent#)
      RexxCounter = RexxCounter + 1
      $firstchar = Substr(yamlrec,1,1)
      If $firstchar = '"' then,
         newRexx.RexxCounter =,
            RexxVarb'.'TextCounter '='yamlrec
      Else,
         newRexx.RexxCounter =,
            RexxVarb'.'TextCounter '="'yamlrec'"'
      TextCounter = TextCounter + 1
   End /* Do Forever */

   newRexx.0 = RexxCounter

   Return next_y# -1


YAMLRecordToRexx:

   RexxVarb = ''
   /* if not listing and no value, then no REXX  (yet)               */
   If Length(YamlValue) = 0 &,
      YamlListCounter.indent# = 0 then  RETURN;

   /* Yaml is listing objects or text */
   If PreviousIndent# = 0 & YamlListCounter.indent# > 0 then,
      Do
      Say 'YAML2REX: starting a list in column 1 is invalid'
      Exit 12
      End                                                          x
   RexxCounter =  newRexx.0
   /* Yaml allows these values to indicate listed data on + lines*/
   If YamlValue = "|" | YamlValue = '>' then,
      Do
      Call DetermineRexxVarb ;
      /* Use YamlListCounter and build Rexx Stem array stmts */
      next_y# = y#
      y# = ConvertListedText() ;
      Return;
      End

   next_y# = y# - 1

   /* Yaml list/ojb  with YamlValue...  Write 1 Rexx equal .  */
   If Length(YamlValue) > 0 then, /* we have a Yaml value  */
      Do /* Since there is a value, write Rexx 1 for 1:    */
      /* Write a line of Rexx output, using YamlListCounter */
      RexxCounter =  newRexx.0 + 1
      Call DetermineRexxVarb ;

      /* if Value is numeric, do not quote it               */
      numericValue = Verify(YamlValue,$Numbers)
      If numericValue > 0 then,
         newRexx.RexxCounter = RexxVarb '="'YamlValue'"'
      Else,
         newRexx.RexxCounter = RexxVarb '='YamlValue
      newRexx.0    = RexxCounter

      Return;
      End /* If listing = 'Objects' */

   /* Yaml list / no   YamlValue...  Save YamlObject     */
   /* This is the indentation level for the 1st in list. */
   multindent# = WordIndex(yamlrec,1)  /* level for the list */
   Return;

   /* Continue through Yaml for remainder of list */
   /*   Loop for all found like this one and Write Rexx equal. */
    Do Forever  /* until the indentation decreases */
       next_y# = next_y# + 1
       if next_y# > yaml.0 then Leave
       yamlrec     = yaml.next_y#
       /* Do the normal scrub of the Yaml input lines */
       validrec = FirstLookAtIndentation() ;
       /* Skip Blank lines and Comment lines */
       If validrec = 0 then Iterate
       /* indentation decreased  ?           */
       if indent# < multindent# then Leave
       RexxVarb = Word(UpperVarb,1)
       Call WriteRexxWithYamlListCounter ;

    End /* Do Forever */

   newRexx.0    = RexxCounter
   y# = next_y# - 1
   /* Initialize these for the next Yaml List */
   IndentLevel_Rexxnodes.multindent# = ''
   listing = 'na'
   next_y# = 0
   Return;

   /* Not a YAML list.....                */
   Return;

   /* Is the Indentation changing ? ...   */
   if indent#  = PreviousIndent# then,
      Call MatchingIndentation /* same indentation level  */
   Else,
   if indent#  > PreviousIndent# then,
      Call IncreasingIndentation
   Else,
   if indent#  < PreviousIndent# then,
      Call DecreasingIndentation ;

   /* The found indentation is now the previous indentation */
   /* Is this a new Object/Word, or repeating one ? */

   If Length(YamlValue) = 0 then, /* we have a Yaml Object */
      Return ;

   /* Multi-lines ? if value is |  or   >       */
   If YamlValue = "|" | YamlValue = '>' then,
      Do
      next_y# = y#
      RexxVarb = Word(UpperVarb,1)'.'YamlObject
      y# = ConvertListedText() ;
      Return;
      End

   RexxVarb = IndentLevel_Rexxnodes.indent#

   If RexxVarb = '' then Return;

   /* contribute to the new Rexx statements  */

   where = Wordpos(RexxVarb,ListRexxVariables)

   thisVariableCount  = ListRexxVarCounts.where
   if thisVariableCount > 0 then,
      Do
      RexxVarb = RexxVarb'.'thisVariableCount
      ListRexxVarCounts.where = ListRexxVarCounts.where +1
      End

   /* If value not numeric, surround with double quotes */
   RexxCounter =  newRexx.0 + 1
   numericValue = Verify(YamlValue,$Numbers)
   If numericValue > 0 then,
      newRexx.RexxCounter =  RexxVarb'="'YamlValue'"'
   Else,
      newRexx.RexxCounter =  RexxVarb'='YamlValue

   newRexx.0    = RexxCounter

   Return

DetermineRexxVarb:

   /* Determine REXX variable from upper and this indentation */
   upperIndent# = IndentLevel_UpperIndent.indent#
   UpperVarb = Word(IndentLevel_Rexxnodes.upperIndent#,1)

   If upperIndent# = 0 then RexxVarb = YamlObject
   Else,
   If YamlListCounter.upperIndent# > 0 then, /* a Yaml List   */
      RexxVarb = Word(UpperVarb,1)'.' ||,
                 YamlListCounter.upperIndent#'.'YamlObject
   Else,                                     /* a Yaml Object */
      RexxVarb = Word(UpperVarb,1)'.'YamlObject

   /* Determine REXX variable also from      this indentation */
   If YamlListCounter.indent# > 0 then,    /* a Yaml List   */
      RexxVarb = RexxVarb'.'YamlListCounter.indent#

   Return

